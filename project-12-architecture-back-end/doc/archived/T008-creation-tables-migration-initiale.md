# T008: Création des tables - Migration initiale avec Alembic

## Description
Créer et appliquer la première migration Alembic pour générer les 4 tables du système CRM Epic Events dans la base de données SQLite.

## Contexte
Cette tâche intervient après la définition des modèles SQLAlchemy (User, Client, Contract, Event). Alembic est déjà configuré (T004), il faut maintenant créer le schéma de base de données.

## Objectif
- Générer automatiquement le script de migration à partir des modèles SQLAlchemy
- Créer les 4 tables dans la base de données : `users`, `clients`, `contracts`, `events`
- Créer les relations (clés étrangères) entre les tables
- Créer les index et contraintes (unique, not null, etc.)

---

## Étape 1 : Vérifier la configuration Alembic

### Vérifier que les modèles sont importés dans env.py

Ouvrez le fichier [migrations/env.py](../migrations/env.py) et vérifiez que tous les modèles sont importés (lignes 18-22) :

```python
from src.models.user import User
from src.models.client import Client
from src.models.contract import Contract
from src.models.event import Event
from src.models import Base
```

**Pourquoi c'est important** : Alembic a besoin d'accéder aux modèles pour détecter les changements et générer la migration. Sans ces imports, Alembic ne verra aucune table à créer.

### Vérifier l'URL de la base de données

Ouvrez [alembic.ini](../alembic.ini) et vérifiez la ligne 87 :

```ini
sqlalchemy.url = sqlite:///epic_events_crm.db
```

**Note** : Ce fichier SQLite sera créé à la racine du projet lors de l'application de la migration.

---

## Étape 2 : Générer la migration initiale

### Commande à exécuter

```bash
poetry run alembic revision --autogenerate -m "Initial migration: create users, clients, contracts, events tables"
```

### Explication de la commande

- `poetry run` : Exécute la commande dans l'environnement virtuel Poetry
- `alembic revision` : Crée un nouveau fichier de migration
- `--autogenerate` : Détecte automatiquement les différences entre les modèles et la base de données
- `-m "message"` : Message descriptif de la migration

### Résultat attendu

Alembic va créer un nouveau fichier dans `migrations/versions/` avec un nom comme :

```
migrations/versions/abc123def456_initial_migration_create_users_clients.py
```

Le nom contient :
- Un identifiant unique (`abc123def456`)
- Le message de la migration (slugifié)

### Sortie dans le terminal

```
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'users'
INFO  [alembic.autogenerate.compare] Detected added table 'clients'
INFO  [alembic.autogenerate.compare] Detected added table 'contracts'
INFO  [alembic.autogenerate.compare] Detected added table 'events'
  Generating migrations/versions/abc123def456_initial_migration_create_users_clients.py ...  done
```

---

## Étape 3 : Examiner le fichier de migration généré

### Ouvrir le fichier créé

Ouvrez `migrations/versions/abc123def456_..._.py` (le nom exact variera) et examinez son contenu.

### Structure du fichier

```python
"""Initial migration: create users, clients, contracts, events tables

Revision ID: abc123def456
Revises:
Create Date: 2025-10-12 14:30:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision: str = 'abc123def456'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=255), nullable=False),
        sa.Column('password_hash', sa.String(length=255), nullable=False),
        sa.Column('first_name', sa.String(length=50), nullable=False),
        sa.Column('last_name', sa.String(length=50), nullable=False),
        sa.Column('phone', sa.String(length=20), nullable=False),
        sa.Column('department', sa.Enum('COMMERCIAL', 'GESTION', 'SUPPORT', name='department'), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email'),
        sa.UniqueConstraint('username')
    )
    op.create_table('clients',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('first_name', sa.String(length=50), nullable=False),
        sa.Column('last_name', sa.String(length=50), nullable=False),
        sa.Column('email', sa.String(length=255), nullable=False),
        sa.Column('phone', sa.String(length=20), nullable=False),
        sa.Column('company_name', sa.String(length=255), nullable=False),
        sa.Column('sales_contact_id', sa.Integer(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.ForeignKeyConstraint(['sales_contact_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email')
    )
    op.create_table('contracts',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('client_id', sa.Integer(), nullable=False),
        sa.Column('sales_contact_id', sa.Integer(), nullable=False),
        sa.Column('total_amount', sa.Numeric(precision=10, scale=2), nullable=False),
        sa.Column('amount_remaining', sa.Numeric(precision=10, scale=2), nullable=False),
        sa.Column('is_signed', sa.Boolean(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.ForeignKeyConstraint(['client_id'], ['clients.id'], ),
        sa.ForeignKeyConstraint(['sales_contact_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    op.create_table('events',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('contract_id', sa.Integer(), nullable=False),
        sa.Column('support_contact_id', sa.Integer(), nullable=True),
        sa.Column('event_name', sa.String(length=255), nullable=False),
        sa.Column('event_start', sa.DateTime(timezone=True), nullable=False),
        sa.Column('event_end', sa.DateTime(timezone=True), nullable=False),
        sa.Column('location', sa.String(length=255), nullable=False),
        sa.Column('attendees', sa.Integer(), nullable=False),
        sa.Column('notes', sa.Text(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('(CURRENT_TIMESTAMP)'), nullable=False),
        sa.ForeignKeyConstraint(['contract_id'], ['contracts.id'], ),
        sa.ForeignKeyConstraint(['support_contact_id'], ['users.id'], ),
        sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('events')
    op.drop_table('contracts')
    op.drop_table('clients')
    op.drop_table('users')
    # ### end Alembic commands ###
```

### Points à vérifier

**✅ Fonction `upgrade()`** : Crée les tables dans l'ordre correct (users → clients/contracts → events)

**✅ Fonction `downgrade()`** : Supprime les tables dans l'ordre inverse (permet de revenir en arrière)

**✅ Clés étrangères** : Les relations sont correctement définies :
- `clients.sales_contact_id` → `users.id`
- `contracts.client_id` → `clients.id`
- `contracts.sales_contact_id` → `users.id`
- `events.contract_id` → `contracts.id`
- `events.support_contact_id` → `users.id`

**✅ Contraintes UNIQUE** : `username`, `email` dans users ; `email` dans clients

**✅ Types Enum** : Le type `Department` est correctement créé

**⚠️ Note** : Si quelque chose semble incorrect, vous pouvez modifier manuellement ce fichier avant de l'appliquer.

---

## Étape 4 : Appliquer la migration

### Commande à exécuter

```bash
poetry run alembic upgrade head
```

### Explication

- `alembic upgrade` : Applique les migrations
- `head` : Jusqu'à la dernière migration disponible

### Résultat attendu

```
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> abc123def456, Initial migration: create users, clients, contracts, events tables
```

### Ce qui se passe en coulisses

1. **Création du fichier de base de données** : `epic_events_crm.db` est créé à la racine
2. **Création de la table alembic_version** : Alembic garde un historique des migrations appliquées
3. **Exécution du script de migration** : Les 4 tables sont créées avec leurs colonnes, contraintes et relations

---

## Étape 5 : Vérifier que les tables sont créées

### Option 1 : Utiliser Python pour inspecter (Recommandé sur Windows)

Créez un petit script temporaire `check_db.py` à la racine du projet :

```python
from sqlalchemy import create_engine, inspect

# Connexion à la base de données
engine = create_engine("sqlite:///epic_events_crm.db")
inspector = inspect(engine)

# Lister toutes les tables
print("=" * 50)
print("Tables dans la base de données:")
print("=" * 50)
for table_name in inspector.get_table_names():
    print(f"  ✓ {table_name}")

# Détails de chaque table
tables = ["users", "clients", "contracts", "events"]
for table in tables:
    print(f"\n{'=' * 50}")
    print(f"Colonnes de la table '{table}':")
    print("=" * 50)
    for column in inspector.get_columns(table):
        nullable = "NULL" if column['nullable'] else "NOT NULL"
        print(f"  • {column['name']:<20} {column['type']:<20} {nullable}")

    # Afficher les clés étrangères
    fks = inspector.get_foreign_keys(table)
    if fks:
        print(f"\n  Clés étrangères:")
        for fk in fks:
            print(f"    → {fk['constrained_columns'][0]} → {fk['referred_table']}.{fk['referred_columns'][0]}")

print("\n" + "=" * 50)
print("✅ Vérification terminée!")
print("=" * 50)
```

Exécutez-le :
```bash
poetry run python check_db.py
```

**Sortie attendue** :
```
==================================================
Tables dans la base de données:
==================================================
  ✓ alembic_version
  ✓ users
  ✓ clients
  ✓ contracts
  ✓ events

==================================================
Colonnes de la table 'users':
==================================================
  • id                   INTEGER              NOT NULL
  • username             VARCHAR(50)          NOT NULL
  • email                VARCHAR(255)         NOT NULL
  • password_hash        VARCHAR(255)         NOT NULL
  • first_name           VARCHAR(50)          NOT NULL
  • last_name            VARCHAR(50)          NOT NULL
  • phone                VARCHAR(20)          NOT NULL
  • department           VARCHAR(10)          NOT NULL
  • created_at           DATETIME             NOT NULL
  • updated_at           DATETIME             NOT NULL

==================================================
Colonnes de la table 'clients':
==================================================
  • id                   INTEGER              NOT NULL
  • first_name           VARCHAR(50)          NOT NULL
  • last_name            VARCHAR(50)          NOT NULL
  • email                VARCHAR(255)         NOT NULL
  • phone                VARCHAR(20)          NOT NULL
  • company_name         VARCHAR(255)         NOT NULL
  • sales_contact_id     INTEGER              NOT NULL
  • created_at           DATETIME             NOT NULL
  • updated_at           DATETIME             NOT NULL

  Clés étrangères:
    → sales_contact_id → users.id

[... etc pour contracts et events ...]

==================================================
✅ Vérification terminée!
==================================================
```

### Option 2 : Utiliser DB Browser for SQLite (Outil graphique)

**Avantage** : Interface visuelle pour explorer la base de données, exécuter des requêtes SQL, voir les relations.

#### Installation sur Windows

1. Téléchargez DB Browser depuis [https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/)
2. Choisissez la version Windows (installeur ou portable)
3. Installez et lancez l'application

#### Utilisation

1. Ouvrez DB Browser for SQLite
2. Cliquez sur "Open Database"
3. Sélectionnez `epic_events_crm.db` dans votre projet
4. Onglet "Database Structure" : Voir toutes les tables et leurs colonnes
5. Onglet "Browse Data" : Voir les données (vide pour l'instant)
6. Onglet "Execute SQL" : Exécuter des requêtes SQL

### Option 3 : Utiliser SQLite CLI (Si disponible)

**Note** : Sur Windows, SQLite CLI n'est pas installé par défaut. Vous pouvez l'ignorer ou l'installer manuellement.

**Installation optionnelle** :
1. Téléchargez depuis [https://sqlite.org/download.html](https://sqlite.org/download.html)
2. Cherchez "Precompiled Binaries for Windows"
3. Téléchargez `sqlite-tools-win-x64-*.zip`
4. Extrayez `sqlite3.exe` dans un dossier de votre PATH ou dans le dossier du projet

**Commandes** :
```bash
# Ouvrir la base de données
sqlite3 epic_events_crm.db

# Lister les tables
.tables

# Afficher le schéma de la table users
.schema users

# Quitter
.quit
```

---

## Étape 6 : Vérifier l'historique des migrations

### Commande pour voir l'état actuel

```bash
poetry run alembic current
```

**Sortie attendue** :
```
abc123def456 (head)
```

### Commande pour voir l'historique complet

```bash
poetry run alembic history
```

**Sortie attendue** :
```
<base> -> abc123def456 (head), Initial migration: create users, clients, contracts, events tables
```

---

## Commandes Alembic utiles

### Voir l'état actuel de la base de données
```bash
poetry run alembic current
```

### Voir toutes les migrations disponibles
```bash
poetry run alembic history
```

### Revenir en arrière d'une migration
```bash
poetry run alembic downgrade -1
```

### Revenir à une version spécifique
```bash
poetry run alembic downgrade abc123def456
```

### Tout supprimer (revenir à la base vide)
```bash
poetry run alembic downgrade base
```

### Voir le SQL qui sera exécuté sans l'appliquer
```bash
poetry run alembic upgrade head --sql
```

---

## Résolution des problèmes courants

### Problème 1 : "No changes detected"

**Symptôme** :
```
INFO  [alembic.autogenerate.compare] Detected no changes.
```

**Causes possibles** :
1. Les modèles ne sont pas importés dans `migrations/env.py`
2. La base de données existe déjà avec les tables

**Solution** :
- Vérifiez les imports dans `env.py`
- Supprimez `epic_events_crm.db` et réessayez
- Vérifiez que `target_metadata = Base.metadata` est bien défini

### Problème 2 : ImportError lors de la génération

**Symptôme** :
```
ImportError: cannot import name 'User' from 'src.models.user'
```

**Solution** :
- Vérifiez que Poetry est bien activé (`poetry shell`)
- Vérifiez que tous les fichiers `__init__.py` existent
- Essayez : `poetry install` pour réinstaller les dépendances

### Problème 3 : La migration ne crée pas les Enum correctement

**Symptôme** : Le type `Department` n'est pas créé

**Solution SQLite** : SQLite ne supporte pas nativement les ENUM, ils sont stockés comme VARCHAR. C'est normal et géré par SQLAlchemy.

### Problème 4 : Erreur de clé étrangère

**Symptôme** :
```
sqlalchemy.exc.IntegrityError: FOREIGN KEY constraint failed
```

**Solution** :
- Vérifiez que les tables sont créées dans le bon ordre (users d'abord)
- Vérifiez que les colonnes référencées existent
- Pour SQLite, activez les clés étrangères : `PRAGMA foreign_keys = ON;`

---

## Fichiers créés/modifiés

### Nouveaux fichiers
- `migrations/versions/abc123def456_initial_migration_create_users_clients.py` (nom exact varie)
- `epic_events_crm.db` (base de données SQLite)

### Fichiers non modifiés
- `alembic.ini`
- `migrations/env.py`
- Tous les modèles dans `src/models/`

---

## Explication pour le mentor OpenClassrooms

### Pourquoi utiliser Alembic ?

**Problème sans Alembic** :
- Chaque développeur devrait exécuter manuellement des scripts SQL
- Risque d'incohérence entre les environnements (dev, staging, prod)
- Difficile de revenir en arrière après un changement de schéma
- Pas d'historique des modifications

**Solution avec Alembic** :
- Génération automatique des migrations à partir des modèles Python
- Historique versionné des changements de schéma (comme Git pour la base de données)
- Commandes `upgrade` / `downgrade` pour avancer/reculer
- Garantit que tous les environnements ont le même schéma

### Workflow de développement avec Alembic

1. **Modifier le modèle** : Ajoutez un champ dans `src/models/user.py`
2. **Générer la migration** : `alembic revision --autogenerate -m "Add avatar field to User"`
3. **Examiner le script** : Vérifiez que la migration est correcte
4. **Appliquer** : `alembic upgrade head`
5. **Committer** : Le fichier de migration est versionné dans Git

### Avantages pour le projet Epic Events

- **Traçabilité** : Chaque changement de schéma est documenté et daté
- **Collaboration** : Les autres développeurs peuvent appliquer les migrations avec une commande
- **Production** : Déploiement sûr des changements de schéma
- **Tests** : Les tests peuvent créer/détruire la base facilement

### Architecture de la base de données

```
users (Collaborateurs Epic Events)
  ├── id (PK)
  ├── username, email (UNIQUE)
  ├── department (ENUM: COMMERCIAL, GESTION, SUPPORT)
  └── timestamps

clients (Clients d'Epic Events)
  ├── id (PK)
  ├── email (UNIQUE)
  ├── sales_contact_id (FK → users.id)
  └── timestamps

contracts (Contrats signés avec les clients)
  ├── id (PK)
  ├── client_id (FK → clients.id)
  ├── sales_contact_id (FK → users.id)
  ├── total_amount, amount_remaining
  ├── is_signed (Boolean)
  └── timestamps

events (Événements organisés pour les contrats)
  ├── id (PK)
  ├── contract_id (FK → contracts.id)
  ├── support_contact_id (FK → users.id, nullable)
  ├── event_start, event_end
  ├── location, attendees, notes
  └── timestamps
```

### Règles métier implémentées au niveau du schéma

1. **Intégrité référentielle** : Un client doit avoir un commercial (FK non nullable)
2. **Unicité des emails** : Pas de doublons dans users et clients
3. **Contraintes de montants** : `amount_remaining ≤ total_amount` (à valider en Python)
4. **Événements optionnels** : Un événement peut ne pas encore avoir de support assigné (nullable)

---

## Critères de complétion

✅ La commande `alembic revision --autogenerate` a généré un fichier de migration
✅ Le fichier de migration contient la création des 4 tables (users, clients, contracts, events)
✅ Les clés étrangères sont correctement définies
✅ La commande `alembic upgrade head` s'exécute sans erreur
✅ Le fichier `epic_events_crm.db` existe à la racine du projet
✅ Les tables sont visibles avec `.tables` dans SQLite CLI
✅ La table `alembic_version` contient la révision actuelle

---

## Prochaines étapes

Une fois les tables créées, vous pourrez :

1. **Créer des utilisateurs initiaux** : Script de seed pour avoir des utilisateurs de test
2. **Implémenter l'authentification** : Service pour login/logout avec JWT
3. **Tester les modèles** : Tests unitaires pour vérifier les relations et contraintes
4. **Créer les commandes CLI** : Interface utilisateur avec Typer/Click
5. **Implémenter les permissions** : Système RBAC basé sur le département

---

## Statut
⏳ **À compléter** - En attente d'exécution des commandes Alembic

## Date de création
2025-10-12
